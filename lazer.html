<!DOCTYPE html>
<html>
<head>
<link rel="icon" type="image/png" href="site.png">
    
    <title>Erdemli Meslekler Galaksisi (V19)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        body { margin: 0; overflow: hidden; background-color: #0d1a26; }
        canvas { display: block; }

        /* Yeni HUD Stili - Daha Keskin ve Sci-Fi */
        #hud-container {
            position: absolute; top: 15px; left: 15px; right: 15px;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            font-family: 'Orbitron', sans-serif; /* Yeni font */
            color: #00FFC0;
            text-shadow: 0 0 4px rgba(0, 255, 192, 0.7);
        }
        .hud-panel {
            background: rgba(10, 20, 30, 0.9); 
            border: 2px solid #00FFC0;
            border-top: none; 
            border-left: none; /* K√∂≈üeleri a√ßƒ±k bƒ±rakarak daha modern bir g√∂r√ºn√ºm */
            padding: 12px 20px; 
            border-radius: 0 5px 5px 0; /* Hafif eƒüim */
            box-shadow: 0 0 15px rgba(0, 255, 192, 0.5);
            transition: all 0.3s;
        }
        .hud-panel h3 { 
            margin-top: 0; margin-bottom: 5px; 
            font-size: 1.2em; color: #FFD700; 
            border-bottom: 1px solid rgba(255, 215, 0, 0.5);
            padding-bottom: 3px;
        }
        .hud-panel p { margin: 5px 0; font-size: 1.3em; }
        #score, #difficulty-level { color: #FFFFFF; font-weight: 700; }

        /* Can Barƒ± Stili */
        #health-panel { width: 280px; }
        #health-bar-container {
            width: 100%;
            height: 20px;
            background-color: #1a3a4a;
            border: 1px solid #00FFC0;
            margin-top: 8px;
            position: relative;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.8);
        }
        #health-bar {
            height: 100%;
            width: 100%;
            background-color: #00FF00;
            transition: width 0.3s ease-out, background-color 0.3s;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
        }
        #health-text {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 20px;
            font-size: 1em;
            color: #1a2a3a;
            font-weight: bold;
            text-shadow: none;
            z-index: 2;
        }

        /* Kontrol Paneli Stili */
        #controls {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
            display: flex;
            gap: 12px;
        }
        .control-button {
            padding: 12px 20px;
            font-size: 15px;
            font-weight: bold;
            color: white;
            background-color: #007bff;
            border: 1px solid #00BFFF;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 10px rgba(0, 191, 255, 0.5);
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
        }
        .control-button:hover {
            background-color: #00BFFF;
            box-shadow: 0 0 15px rgba(0, 191, 255, 1);
        }
        #pause-button {
            background-color: #ffc107;
            color: #333;
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
        }
        #pause-button:hover {
            background-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 1);
        }
        #menu-button {
            background-color: #dc3545;
            border-color: #FF0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }
        #menu-button:hover {
            background-color: #FF0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 1);
        }
        
        /* Uyarƒ± ve Oyun Bitti Ekranlarƒ± */
        #level-alert, #game-over-screen {
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            color: #FFD700; 
            font-size: 48px;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px 80px;
            border-radius: 10px;
            border: 4px solid #FF0000;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
            display: none; 
            z-index: 500;
            text-align: center;
            font-family: 'Orbitron', sans-serif;
        }
        #game-over-screen h2 {
            font-size: 72px;
            color: #FF0000;
            margin-bottom: 25px;
            text-shadow: 0 0 10px #FF0000;
        }
        #game-over-screen p {
             font-size: 1.5em;
             margin-bottom: 30px;
        }
        #game-over-screen button {
            margin: 10px;
            padding: 15px 35px;
            font-size: 16px;
        }
        
        /* Hasar Geri Bildirim Overlay */
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0);
            pointer-events: none;
            transition: background-color 0.1s;
            z-index: 499;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://threejs.org/examples/js/loaders/FontLoader.js"></script>
    <script src="https://threejs.org/examples/js/geometries/TextGeometry.js"></script>
</head>
<body>
    
    <div id="hud-container">
        <div id="health-panel" class="hud-panel">
            <h3>üõ°Ô∏è ENERJƒ∞ SEVƒ∞YESƒ∞</h3>
            <div id="health-bar-container">
                <div id="health-bar"></div>
                <span id="health-text">100 / 100</span>
            </div>
        </div>
        
        <div id="info-panel" class="hud-panel">
            <p>SKOR: <span id="score">0</span></p>
            <p>SEVƒ∞YE: <span id="difficulty-level">1 (√áOK KOLAY)</span></p>
        </div>
    </div>
    
    <div id="damage-overlay"></div>
    
    <div id="controls">
        <button id="pause-button" class="control-button">OYUNU DURDUR</button>
        <button id="restart-button" class="control-button">YENƒ∞DEN BA≈ûLAT</button>
        <button id="menu-button" class="control-button">ANA MEN√ú</button>
    </div>

    <div id="level-alert"></div>
    
    <div id="game-over-screen">
        <h2>Sƒ∞STEM √á√ñKT√ú</h2>
        <p>SON SKOR: <span id="final-score">0</span></p>
        <button onclick="window.location.reload()" class="control-button">TEKRAR BA≈ûLAT</button>
        <button onclick="window.location.href = 'oyun.html'" class="control-button" id="menu-button">ANA MEN√úYE D√ñN</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- Oyun Durumu ve Kontrol Deƒüi≈ükenleri ---
        let isPaused = false; 
        let isGameOver = false;
        let health = 100;
        let targetRotationY = 0;
        let targetRotationX = 0;
        let currentMouseX = 0;
        let currentMouseY = 0;
        const LERP_FACTOR = 0.08; // Kamera yumu≈üatma fakt√∂r√º (D√º≈ü√ºk deƒüer daha yumu≈üak)

        // --- T√ºrk√ße Karakter D√ºzeltme Fonksiyonu ---
        function cleanTurkish(text) {
            text = text.toUpperCase();
            text = text.replace(/ƒ∞/g, 'I');
            text = text.replace(/√ú/g, 'U');
            text = text.replace(/≈û/g, 'S');
            text = text.replace(/√á/g, 'C');
            text = text.replace(/ƒû/g, 'G');
            text = text.replace(/√ñ/g, 'O');
            return text;
        }

        // --- 1. Temel Kurulum ve UI Elementleri ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0d1a26); 
        scene.fog = new THREE.Fog(0x1a2a3a, 100, 300); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('gameCanvas') });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        camera.position.set(0, 0, 10); 
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1.5);
        pointLight.position.set(0, 0, 10);
        scene.add(pointLight);

        // UI Elementleri ve Kontroller
        const scoreElement = document.getElementById('score');
        const difficultyElement = document.getElementById('difficulty-level');
        const alertElement = document.getElementById('level-alert');
        const pauseButton = document.getElementById('pause-button');
        const restartButton = document.getElementById('restart-button');
        const menuButton = document.getElementById('menu-button');
        const healthBar = document.getElementById('health-bar');
        const healthText = document.getElementById('health-text');
        const damageOverlay = document.getElementById('damage-overlay');
        const gameOverScreen = document.getElementById('game-over-screen');

        // --- Oyun Kontrol Fonksiyonlarƒ± ---

        function togglePause() {
            if (isGameOver) return;
            isPaused = !isPaused;
            if (isPaused) {
                pauseButton.textContent = 'OYUNU BA≈ûLAT';
                showAlert('DURAKLATILDI');
            } else {
                pauseButton.textContent = 'OYUNU DURDUR';
                alertElement.style.display = 'none';
            }
        }
        
        function updateHealth(delta) {
            health = Math.max(0, Math.min(100, health + delta));
            const percent = health;

            healthBar.style.width = percent + '%';
            healthText.textContent = `${Math.floor(health)} / 100`;

            // Can Barƒ± Renk Ge√ßi≈üi
            if (percent > 50) {
                healthBar.style.backgroundColor = '#00FF00';
                healthBar.style.boxShadow = '0 0 10px rgba(0, 255, 0, 0.8)';
            } else if (percent > 20) {
                healthBar.style.backgroundColor = '#FFD700';
                healthBar.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.8)';
            } else {
                healthBar.style.backgroundColor = '#FF0000';
                healthBar.style.boxShadow = '0 0 10px rgba(255, 0, 0, 0.8)';
            }

            if (health <= 0 && !isGameOver) {
                gameOver();
            }
        }

        function takeDamage(amount, type) {
            if (isGameOver) return;

            // Kamera Sarsƒ±ntƒ±sƒ±
            cameraShake(0.5, 0.5);

            // Hasar Overlay Geri Bildirimi (Kƒ±sa S√ºreli Kƒ±rmƒ±zƒ± Ekran)
            damageOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            setTimeout(() => {
                damageOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0)';
            }, 100);

            updateHealth(-amount);
        }

        function gameOver() {
            isGameOver = true;
            isPaused = true;
            pauseButton.textContent = 'OYUN Bƒ∞TTƒ∞';
            pauseButton.disabled = true;
            document.getElementById('final-score').textContent = score;
            gameOverScreen.style.display = 'flex';
            
            targets.forEach(t => scene.remove(t));
            targets.length = 0;
            shots.forEach(s => scene.remove(s));
            shots.length = 0;
        }

        // --- Buton Event Listener'larƒ± ---
        pauseButton.addEventListener('click', togglePause);
        restartButton.addEventListener('click', () => { window.location.reload(); });
        menuButton.addEventListener('click', () => { window.location.href = 'oyun.html'; });
        updateHealth(0); 
        
        // --- 2. G√∂rsel Bile≈üenler ---
        
        function createAdvancedPlanetTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128; 
            const ctx = canvas.getContext('2d');
            const colorPalettes = [
                { baseHue: 270, baseSaturation: 70, baseLightness: 50, cloudHueOffset: 30, cloudSaturation: 50, cloudLightness: 30 }, 
                { baseHue: 40, baseSaturation: 70, baseLightness: 60, cloudHueOffset: 20, cloudSaturation: 40, cloudLightness: 20 }, 
                { baseHue: 200, baseSaturation: 80, baseLightness: 40, cloudHueOffset: 40, cloudSaturation: 60, cloudLightness: 30 },
                { baseHue: 120, baseSaturation: 60, baseLightness: 40, cloudHueOffset: 30, cloudSaturation: 50, cloudLightness: 20 },
                { baseHue: 0, baseSaturation: 80, baseLightness: 40, cloudHueOffset: 20, cloudSaturation: 50, cloudLightness: 20 },
                { baseHue: 330, baseSaturation: 90, baseLightness: 55, cloudHueOffset: 25, cloudSaturation: 60, cloudLightness: 35 }, 
                { baseHue: 60, baseSaturation: 80, baseLightness: 65, cloudHueOffset: 15, cloudSaturation: 50, cloudLightness: 30 } 
            ];
            const selectedPalette = colorPalettes[Math.floor(Math.random() * colorPalettes.length)];
            const baseColor = `hsl(${selectedPalette.baseHue + (Math.random() * 20 - 10)}, ${selectedPalette.baseSaturation + (Math.random() * 20 - 10)}%, ${selectedPalette.baseLightness + (Math.random() * 20 - 10)}%)`;
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < 30; i++) { 
                const hue = selectedPalette.baseHue + (Math.random() * selectedPalette.cloudHueOffset * 2 - selectedPalette.cloudHueOffset);
                const saturation = selectedPalette.cloudSaturation + (Math.random() * 30 - 15);
                const lightness = selectedPalette.cloudLightness + (Math.random() * 30 - 15);
                const opacity = 0.6 + Math.random() * 0.4; 
                ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${opacity})`;
                const startX = Math.random() * canvas.width;
                const startY = Math.random() * canvas.height;
                const width = 60 + Math.random() * 180; 
                const height = 20 + Math.random() * 60; 
                const rotation = Math.random() * Math.PI * 2;
                ctx.save();
                ctx.translate(startX, startY);
                ctx.rotate(rotation);
                ctx.fillRect(-width / 2, -height / 2, width, height);
                ctx.restore();
            }
            return new THREE.CanvasTexture(canvas);
        }

        // Gezegen Olu≈üturma Fonksiyonu (Atmosphere Glow eklendi)
        const planets = [];
        function createPlanet(radius, x, y, z, hasRing = false) {
            const group = new THREE.Group(); 
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const texture = createAdvancedPlanetTexture(); 
            
            const material = new THREE.MeshPhongMaterial({ 
                map: texture, 
                shininess: 30, 
                emissive: 0x888888, 
                emissiveIntensity: 1.0 
            });
            const planet = new THREE.Mesh(geometry, material);
            group.add(planet);

            // Atmosfer Glow (Parƒ±ltƒ±)
            const atmosphereGeometry = new THREE.SphereGeometry(radius * 1.05, 32, 32); 
            const atmosphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x00BFFF,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide 
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            group.add(atmosphere);

            if (hasRing) {
                const ringGeometry = new THREE.RingGeometry(radius * 1.2, radius * 1.5, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFFD700, side: THREE.DoubleSide, transparent: true, opacity: 0.9 
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2; 
                ring.rotation.y = Math.random() * Math.PI; 
                group.add(ring);
            }

            group.position.set(x, y, z);
            scene.add(group);
            planets.push(group); 
            return group;
        }

        // Gezegenler
        createPlanet(50, 150, 50, -300); createPlanet(30, -150, -80, -450); 
        createPlanet(70, -20, 150, -600); createPlanet(40, 200, -100, -800);
        createPlanet(60, -250, 80, -950); createPlanet(45, 100, -180, -1100, true); 
        createPlanet(55, -300, 120, -1300);

        // Yƒ±ldƒ±zlar
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 2.0, vertexColors: true }); 
        const starVertices = [];
        const starColors = [];
        const starColorOptions = [
            new THREE.Color(0xFFFFFF), new THREE.Color(0xADD8E6), new THREE.Color(0xFFFDD0),
            new THREE.Color(0xFFE0B2), new THREE.Color(0xB0E0E6)
        ];
        for (let i = 0; i < 70000; i++) { 
            const x = (Math.random() - 0.5) * 5000;
            const y = (Math.random() - 0.5) * 5000;
            const z = -50 - (Math.random() * 950); 
            starVertices.push(x, y, z);
            const randomColor = starColorOptions[Math.floor(Math.random() * starColorOptions.length)];
            starColors.push(randomColor.r, randomColor.g, randomColor.b);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3)); 
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Kuyruklu Yƒ±ldƒ±zlar 
        const comets = [];
        let cometSpawnTimer = 0;
        const cometSpawnInterval = 2.5; 
        
        function createComet() {
            const cometHeadGeometry = new THREE.SphereGeometry(0.7, 8, 8); 
            const cometHeadMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, emissive: 0xFFFFFF, emissiveIntensity: 5 }); 
            const cometHead = new THREE.Mesh(cometHeadGeometry, cometHeadMaterial);
            const tailGeometry = new THREE.BufferGeometry();
            const tailMaterial = new THREE.PointsMaterial({
                color: 0xADD8E6, size: 0.6, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending 
            });
            const tailVertices = [];
            for (let i = 0; i < 80; i++) { tailVertices.push(0, 0, 0); }
            tailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(tailVertices, 3));
            const cometTail = new THREE.Points(tailGeometry, tailMaterial);
            cometHead.add(cometTail); 
            const direction = new THREE.Vector3(
                (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, -1 - Math.random() * 1.5 
            ).normalize();
            const startX = (Math.random() - 0.5) * 300; 
            const startY = (Math.random() - 0.5) * 250;
            const startZ = -50 - Math.random() * 500; 
            cometHead.position.set(startX, startY, startZ);
            cometHead.userData = {
                direction: direction, speed: 2.5 + Math.random() * 3, lifetime: 0, maxLifetime: 200 
            };
            scene.add(cometHead);
            comets.push(cometHead);
        }

        // --- 3. Oyun Deƒüi≈ükenleri ve Deƒüerler ---
        const targets = [];
        const shots = []; 
        let score = 0;
        let lastLevel = 1;
        let font;
        
        const goodValues = ['ADALET', 'VEFA', 'DOGRULUK', 'COMERTLIK', 'SAYGI', 'HIKMET', 'IFFET', 'HOSGORU', 'KANAAT', 'MERHAMET', 'SEVECENLIK', 'SOZUNDE DURMA', 'ALCAK GONULLULUK'];
        const badValues = ['HILE', 'HARAM', 'YALAN', 'CIMRILIK', 'KIBIR', 'NANKORLUK', 'HAINLIK', 'KORKAKLIK', 'HAKSIZLIK', 'ACGOZLULUK', 'ZALIMLIK', 'SOZDEN CAYMA', 'KAPI KAPAMA'];

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(); 
        
        // Kamera Sarsƒ±ntƒ±sƒ± (Shake) i√ßin Deƒüi≈ükenler
        let shakeDuration = 0;
        let shakeIntensity = 0;
        let baseCamPos = camera.position.clone();

        function cameraShake(duration, intensity) {
            shakeDuration = duration;
            shakeIntensity = intensity;
        }

        // Three.js FontLoader
        const fontLoader = new THREE.FontLoader();
        fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (response) {
            font = response;
            for(let i = 0; i < 15; i++) {
                createTarget();
            }
            animate(); 
        });
        
        // --- 4. Zorluk Seviyesi Ayarlama ve Uyarƒ± Fonksiyonlarƒ± ---
        function getDifficulty(currentScore) {
            const level = Math.floor(currentScore / 100) + 1;
            let speedBase, maxTargets, oscillationFactor, spawnRate, levelName;
            const speedMultiplier = (level - 1) * 0.08; 
            if (level === 1) { levelName = "√áOK KOLAY"; } 
            else if (level === 2) { levelName = "KOLAY"; } 
            else if (level === 3) { levelName = "ORTA"; } 
            else { levelName = "ZOR"; }
            const baseSpeed = 0.05;
            const baseOscillation = 0.8;
            speedBase = baseSpeed + speedMultiplier;
            maxTargets = 15 + (level - 1) * 10;
            oscillationFactor = baseOscillation + (level - 1) * 0.7;
            spawnRate = 0.01 + (level - 1) * 0.008; 
            return { level, speedBase, maxTargets, oscillationFactor, spawnRate, levelName };
        }

        function showAlert(message) {
            alertElement.innerHTML = message;
            alertElement.style.display = 'block';
            setTimeout(() => {
                if (!isPaused && !isGameOver) {
                    alertElement.style.display = 'none';
                }
            }, 2000); 
        }

        // --- 5. Hedef Olu≈üturma ---
        function createTarget() {
            if (!font) return; 
            const difficulty = getDifficulty(score);
            const isBad = Math.random() < 0.5;
            const values = isBad ? badValues : goodValues;
            const rawName = values[Math.floor(Math.random() * values.length)];
            const name = cleanTurkish(rawName);

            const textGeometry = new THREE.TextGeometry(name, {
                font: font, size: 2, height: 0.3, curveSegments: 12,
                bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.05, bevelSegments: 5
            });
            textGeometry.computeBoundingBox(); 
            const randomColor = new THREE.Color(Math.random() * 0xffffff);
            const material = new THREE.MeshPhongMaterial({ 
                color: randomColor, emissive: randomColor, emissiveIntensity: 0.3
            });
            const target = new THREE.Mesh(textGeometry, material);

            textGeometry.translate(
                -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x),
                -0.5 * (textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y),
                -0.5 * (textGeometry.boundingBox.max.z - textGeometry.boundingBox.min.z)
            );

            let xPos, yPos, zDistance;
            let attempts = 0;
            const safeDistance = 10; 
            
            do {
                zDistance = -100 - Math.random() * 100; 
                xPos = (Math.random() - 0.5) * 60;
                yPos = (Math.random() - 0.5) * 40;
                let isOverlapping = false;
                for (const existingTarget of targets) {
                    if (Math.abs(existingTarget.position.z - zDistance) < safeDistance &&
                        existingTarget.position.distanceTo(new THREE.Vector3(xPos, yPos, zDistance)) < safeDistance) {
                        isOverlapping = true;
                        break;
                    }
                }
                if (!isOverlapping) break;
                attempts++;
            } while (attempts < 20); 

            target.position.set(xPos, yPos, zDistance);
            target.lookAt(camera.position); 
            
            target.userData = {
                isBad: isBad, name: name,
                speed: difficulty.speedBase + Math.random() * 0.1, 
                baseSpeed: difficulty.speedBase, 
                oscillation: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.05 * difficulty.oscillationFactor, 
                    (Math.random() - 0.5) * 0.05 * difficulty.oscillationFactor, 
                    0
                ),
                timeOffset: Math.random() * Math.PI * 2 
            };

            if (isBad) {
                const ringGeometry = new THREE.RingGeometry(2.5, 2.7, 32); 
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFF0000, side: THREE.DoubleSide, transparent: true, opacity: 0.7, depthWrite: false
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.z = -0.5; 
                target.add(ring); 
            }
            
            scene.add(target);
            targets.push(target);
        }

        // --- 6. Ate≈ü Animasyonu ---
        function createShot() {
            if (isPaused || isGameOver) return; 

            // Lazer Ba≈üƒ±
            const shotGeometry = new THREE.SphereGeometry(0.2, 8, 8); 
            const shotMaterial = new THREE.MeshBasicMaterial({ color: 0x00FF00, emissive: 0x00FF00, emissiveIntensity: 2 }); 
            const shot = new THREE.Mesh(shotGeometry, shotMaterial);
            
            // Lazer Trail (Kuyruk)
            const trailGeometry = new THREE.BufferGeometry();
            const trailVertices = new Float32Array(3 * 10); 
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailVertices, 3));
            
            const trailMaterial = new THREE.PointsMaterial({
                color: 0x00FF00, size: 0.3, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending 
            });
            const trail = new THREE.Points(trailGeometry, trailMaterial);
            shot.add(trail);

            shot.position.copy(camera.position); 
            
            const direction = new THREE.Vector3();
            raycaster.setFromCamera(mouse, camera); 
            direction.copy(raycaster.ray.direction).normalize();

            shot.userData.direction = direction;
            shot.userData.speed = 1.5; 
            shot.userData.trailLength = 10;
            
            scene.add(shot);
            shots.push(shot);
        }

        document.addEventListener('mousemove', (event) => {
            currentMouseX = event.clientX;
            currentMouseY = event.clientY;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        });

        document.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            createShot();
        }, false);
        
        // Vuru≈ü Mantƒ±ƒüƒ± (D√ºzeltildi)
        function processHit(hitTarget) {
            
            if (hitTarget.userData.isBad) {
                // Kƒ±rmƒ±zƒ± Halkalƒ± (K√∂t√º Deƒüer) vuruldu, DOƒûRU VURU≈û
                score += 10; 
                const explosionLight = new THREE.PointLight(0xFFD700, 10, 20); 
                explosionLight.position.copy(hitTarget.position);
                scene.add(explosionLight);
                setTimeout(() => { scene.remove(explosionLight); }, 150); 
                cameraShake(0.3, 0.4); 
            } else {
                // ƒ∞yi Deƒüer vuruldu, YANLI≈û VURU≈û
                score = Math.max(0, score - 5); 
                takeDamage(20, 'wrong-target'); // 20 can hasarƒ±
            }
            
            scene.remove(hitTarget);
            targets.splice(targets.indexOf(hitTarget), 1);
            scoreElement.textContent = score;
        }

        // --- 7. Animasyon D√∂ng√ºs√º (Kamera Yumu≈üatma Eklendi) ---
        let clock = new THREE.Clock();

        function animate() {
            if (!font) {
                 requestAnimationFrame(animate);
                 return;
            }

            if (isPaused || isGameOver) {
                renderer.render(scene, camera);
                return; 
            }

            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const difficulty = getDifficulty(score);

            if (difficulty.level !== lastLevel) {
                difficultyElement.textContent = `${difficulty.level} (${difficulty.levelName})`;
                showAlert(`SEVƒ∞YE ${difficulty.level}! ZORLUK ARTTI! Hƒ±zlandƒ±!`);
                
                targets.forEach(target => {
                    target.userData.speed = difficulty.speedBase + Math.random() * 0.1; 
                    target.userData.oscillation = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.05 * difficulty.oscillationFactor, 
                        (Math.random() - 0.5) * 0.05 * difficulty.oscillationFactor, 
                        0
                    );
                });
                lastLevel = difficulty.level;
            }
            
            // Kamera Yumu≈üatma ve Eƒüilme (Roll) Sistemi
            
            // 1. Hedef Rotasyonlarƒ± Hesapla
            const normalizedMouseX = (currentMouseX / window.innerWidth) * 2 - 1;
            const normalizedMouseY = -(currentMouseY / window.innerHeight) * 2 + 1;
            const maxLookRotation = Math.PI / 36; // Max 5 derece bakƒ±≈ü a√ßƒ±sƒ±
            const maxRoll = Math.PI / 18; // Max 10 derece Roll (Eƒüilme)
            
            // Hedef X ve Y Rotasyonu (Bakƒ±≈ü A√ßƒ±sƒ±)
            targetRotationY = -normalizedMouseX * maxLookRotation; 
            targetRotationX = -normalizedMouseY * maxLookRotation;

            // Hedef Z Rotasyonu (Roll/Eƒüilme)
            let targetRotationZ = -normalizedMouseX * maxRoll;
            
            // 2. Mevcut Rotasyonlarƒ± Hedef Rotasyonlara Doƒüru Yumu≈üat
            camera.rotation.y += (targetRotationY - camera.rotation.y) * LERP_FACTOR;
            camera.rotation.x += (targetRotationX - camera.rotation.x) * LERP_FACTOR;
            camera.rotation.z += (targetRotationZ - camera.rotation.z) * LERP_FACTOR; // Roll

            // 3. Kamera Sarsƒ±ntƒ±sƒ± Uygula
            if (shakeDuration > 0) {
                camera.position.x = baseCamPos.x + (Math.random() * 2 - 1) * shakeIntensity * shakeDuration;
                camera.position.y = baseCamPos.y + (Math.random() * 2 - 1) * shakeIntensity * shakeDuration;
                shakeDuration -= delta;
            } else {
                camera.position.copy(baseCamPos); 
            }


            // Gezegenleri ve Yƒ±ldƒ±zlarƒ± D√∂nd√ºr
            stars.rotation.x += 0.00005; 
            stars.rotation.y += 0.0001;
            planets.forEach(p => { 
                p.rotation.y += 0.0002 + Math.random() * 0.0001;
                p.rotation.x += 0.0001 + Math.random() * 0.00005;
            });
            
            // Kuyruklu Yƒ±ldƒ±zlarƒ± G√ºncelle
            cometSpawnTimer += delta;
            if (cometSpawnTimer >= cometSpawnInterval) {
                createComet();
                cometSpawnTimer = 0;
            }

            for (let i = 0; i < comets.length; i++) {
                const comet = comets[i];
                comet.position.add(comet.userData.direction.clone().multiplyScalar(comet.userData.speed * delta * 60));
                comet.userData.lifetime++;
                const tailPositions = comet.children[0].geometry.attributes.position.array;
                for(let j = tailPositions.length / 3 - 1; j > 0; j--) {
                    tailPositions[j * 3] = tailPositions[(j - 1) * 3];
                    tailPositions[j * 3 + 1] = tailPositions[(j - 1) * 3 + 1];
                    tailPositions[j * 3 + 2] = tailPositions[(j - 1) * 3 + 2];
                }
                tailPositions[0] = 0; tailPositions[1] = 0; tailPositions[2] = 0;
                comet.children[0].geometry.attributes.position.needsUpdate = true;

                if (comet.userData.lifetime > comet.userData.maxLifetime || comet.position.z > camera.position.z + 50) { 
                    scene.remove(comet);
                    comets.splice(i, 1);
                    i--;
                }
            }

            // Hedefleri G√ºncelle (Ka√ßma Kontrol√º)
            for (let i = 0; i < targets.length; i++) {
                const target = targets[i];
                
                target.position.z += target.userData.speed * delta * 60; 
                target.position.x += target.userData.oscillation.x * Math.sin(target.userData.timeOffset + performance.now() * 0.001);
                target.position.y += target.userData.oscillation.y * Math.cos(target.userData.timeOffset + performance.now() * 0.001);
                
                if (target.position.z > 8) {
                    
                    if (target.userData.isBad) {
                        // K√∂t√º hedef ka√ßtƒ±, vurulmasƒ± gerekiyordu, skor d√º≈üer.
                        score = Math.max(0, score - 5); 
                        scoreElement.textContent = score;
                    } 
                    // ƒ∞yi hedef ka√ßarsa, zaten vurulmamasƒ± gerektiƒüi i√ßin can veya skor kaybƒ± yok.

                    scene.remove(target);
                    targets.splice(i, 1);
                    i--;
                }
            }
            
            // Lazer Mermilerini G√ºncelle ve √áarpƒ±≈üma Kontrol√º Yap
            for (let i = 0; i < shots.length; i++) {
                const shot = shots[i];
                shot.position.add(shot.userData.direction.clone().multiplyScalar(shot.userData.speed * 60 * delta)); 

                // Lazer Trail G√ºncelleme
                const trail = shot.children[0];
                const trailPositions = trail.geometry.attributes.position.array;
                for(let k = shot.userData.trailLength - 1; k > 0; k--) {
                    trailPositions[k * 3] = trailPositions[(k - 1) * 3];
                    trailPositions[k * 3 + 1] = trailPositions[(k - 1) * 3 + 1];
                    trailPositions[k * 3 + 2] = trailPositions[(k - 1) * 3 + 2];
                }
                // Trail'in ba≈üƒ±nƒ± sƒ±fƒ±rla, yani merminin pozisyonuna g√∂re hareket eder.
                trailPositions[0] = 0; trailPositions[1] = 0; trailPositions[2] = 0;
                trail.geometry.attributes.position.needsUpdate = true;


                if (shot.position.z < -200) { 
                    scene.remove(shot);
                    shots.splice(i, 1);
                    i--;
                    continue; 
                }

                const shotBox = new THREE.Box3().setFromObject(shot);
                let hitTargetIndex = -1;
                for (let j = 0; j < targets.length; j++) {
                    const target = targets[j];
                    const targetBox = new THREE.Box3().setFromObject(target);
                    
                    if (shotBox.intersectsBox(targetBox)) {
                        hitTargetIndex = j;
                        break;
                    }
                }

                if (hitTargetIndex !== -1) {
                    processHit(targets[hitTargetIndex]); 
                    scene.remove(shot);
                    shots.splice(i, 1);
                    i--;
                }
            }
            
            // Rastgele aralƒ±klarla yeni hedef olu≈ütur
            if (Math.random() < difficulty.spawnRate && targets.length < difficulty.maxTargets) { 
                createTarget();
            }

            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
